# gotunnel 设计注意点与最佳实践

**Language:** [English](../en/07-DESIGN-NOTES.md) | [中文](./07-DESIGN-NOTES.md)

本文档总结了 gotunnel 项目在设计和实现过程中的关键注意点、技术决策和最佳实践，供开发者和维护者参考。

## 一、核心设计原则

### 1. 双通道架构设计

**设计理念：**
- **控制通道**：用于注册、心跳、状态同步等控制消息（长连接）
- **数据通道**：用于实际业务流量转发（按需建立）

**为什么这样设计？**
- 控制通道保持长连接，便于实时管理和监控
- 数据通道按需建立，避免资源浪费
- 分离设计便于后续扩展（如多路复用、负载均衡）

**注意事项：**
- 控制通道断开后，所有数据通道应立即关闭
- 数据通道异常不应影响控制通道的稳定性

### 2. 消息边界处理

**问题背景：**
TCP 是字节流协议，直接传输 JSON 或二进制消息会遇到粘包/分包问题。

**解决方案：**
采用"长度前缀"协议：
```
[4字节长度(大端)] + [消息体(JSON/二进制)]
```

**实现要点：**
```go
// 发送：先写长度，再写内容
binary.BigEndian.PutUint32(lenBuf[:], uint32(len(payload)))
w.Write(lenBuf[:])
w.Write(payload)

// 接收：先读长度，再读完整内容
io.ReadFull(r, lenBuf[:])
length := binary.BigEndian.Uint32(lenBuf[:])
io.ReadFull(r, buf[:length])
```

**关键注意点：**
- 使用 `io.ReadFull` 确保读取完整数据
- 长度字段使用大端序（BigEndian）保证跨平台兼容
- 设置最大消息长度限制（如 0x7fffffff）防止恶意大包攻击

### 3. 全透明数据转发

**设计目标：**
支持任意 TCP 协议（SSH、HTTP、MySQL、Redis 等），不进行任何协议解析。

**实现方式：**
```go
func RelayConn(a, b net.Conn) {
    // 双向转发：a->b 和 b->a 同时进行
    go func() {
        io.Copy(b, a)
        b.Close()
    }()
    io.Copy(a, b)
    a.Close()
}
```

**关键注意点：**
- 使用 `io.Copy` 进行高效的数据拷贝
- 必须双向转发（全双工）
- 任意一端关闭时，应立即关闭另一端
- 使用 goroutine 实现并发转发

## 二、高可用机制

### 1. 心跳保活机制

**设计目的：**
- 检测连接是否存活
- 及时发现网络异常
- 自动清理僵尸连接

**实现策略：**

**客户端：**
- 每 10 秒发送一次 ping
- 收到 pong 后更新状态
- 发送失败触发重连

**服务端：**
- 每 5 秒检查一次所有客户端心跳
- 超过 30 秒未收到心跳则断开连接
- 自动清理映射表

**注意事项：**
- 心跳间隔要平衡：太短浪费资源，太长检测延迟大
- 超时时间要合理：太短容易误判，太长资源泄漏
- 心跳失败应立即触发重连，不要等待

### 2. 自动重连机制

**设计目标：**
网络异常时自动恢复连接，保证服务可用性。

**实现策略：**
- 指数退避：1s → 2s → 4s → 8s → 16s（最大）
- 随机抖动：避免多个客户端同时重连造成风暴
- 最大重试次数：防止无限重试

**注意事项：**
- 重连成功后需要重新注册端口
- 重连期间应暂停健康探针
- 重连失败应记录日志便于排查

### 3. 健康探针机制

**设计目的：**
- 检测本地服务是否存活
- 避免"黑洞代理"（本地服务已死但映射仍存在）
- 自动上下线端口映射

**实现策略：**
- 每 30 秒检查一次本地端口
- 端口 down → 通知服务端下线
- 端口恢复 → 通知服务端重新上线

**注意事项：**
- 探针间隔要合理，避免频繁检查
- 探针失败不应立即下线，可设置连续失败次数阈值
- 探针恢复后应立即通知服务端上线

## 三、并发安全

### 1. 共享资源保护

**问题：**
多个 goroutine 同时访问 `mappingTable` 会导致数据竞争。

**解决方案：**
```go
var mappingTable = make(map[int]*Mapping)
var mappingTableMu sync.Mutex

// 访问时加锁
mappingTableMu.Lock()
defer mappingTableMu.Unlock()
// 操作 mappingTable
```

**注意事项：**
- 锁的粒度要小，避免长时间持有锁
- 使用 `defer` 确保锁一定会释放
- 避免在持有锁时进行网络 I/O 操作

### 2. 连接管理

**设计原则：**
- 每个客户端连接独立 goroutine 处理
- 连接关闭时清理所有相关资源
- 使用 `defer` 确保资源释放

**注意事项：**
- 不要在循环中使用 `defer`（会导致资源泄漏）
- 连接关闭后应立即从映射表中删除
- 关闭连接时忽略错误（`_ = conn.Close()`）

## 四、错误处理

### 1. 统一错误码

**设计目的：**
便于错误定位和问题排查。

**实现方式：**
```go
const (
    ErrConnectServer = 1001  // 连接服务端失败
    ErrAuthFailed    = 1002  // 认证失败
)
```

**注意事项：**
- 错误码要有唯一性
- 错误消息要清晰明确
- 记录详细的错误上下文

### 2. 错误处理策略

**网络错误：**
- 连接失败 → 自动重连
- 读取超时 → 关闭连接
- 写入失败 → 记录日志并关闭

**业务错误：**
- 认证失败 → 立即断开，不重连
- 注册失败 → 记录日志，可重试
- 协议错误 → 记录日志，关闭连接

## 五、性能优化

### 1. 连接池管理

**当前实现：**
- 控制通道：每个客户端一个长连接
- 数据通道：按需建立，用完即关

**优化建议：**
- 未来可考虑数据通道连接池
- 控制通道可支持多路复用（一个控制通道管理多个数据通道）

### 2. 内存管理

**注意事项：**
- 及时释放不用的连接和缓冲区
- 避免大对象长期持有
- 使用对象池减少 GC 压力（如需要）

### 3. 网络优化

**注意事项：**
- 使用 `io.Copy` 进行高效数据拷贝
- 避免不必要的数据拷贝
- 合理设置缓冲区大小

## 六、安全考虑

### 1. 认证机制

**当前实现：**
- Token 认证（简单但有效）

**注意事项：**
- Token 应足够复杂，避免被猜测
- 生产环境必须修改默认 token
- 未来可考虑 TLS 加密控制通道

### 2. 资源限制

**注意事项：**
- 限制最大消息长度（防止大包攻击）
- 限制单个客户端的端口映射数量
- 限制并发连接数

### 3. 日志安全

**注意事项：**
- 不要记录敏感信息（token、密码等）
- 生产环境使用适当的日志级别
- 定期清理日志文件

## 七、代码质量

### 1. 测试覆盖

**目标：**
- 单元测试覆盖率 > 80%
- 核心功能 100% 覆盖

**注意事项：**
- 测试要覆盖正常流程和异常流程
- 使用 mock 对象隔离外部依赖
- 测试要独立，不依赖执行顺序

### 2. 代码规范

**遵循标准：**
- Google Go 编程规范
- 使用 `golangci-lint` 进行代码检查
- 使用 `gofmt` 格式化代码

**注意事项：**
- 导出函数必须有注释
- 错误必须明确处理
- 避免使用 `_` 忽略重要错误

### 3. 可维护性

**设计原则：**
- 函数职责单一
- 代码结构清晰
- 便于扩展和修改

**注意事项：**
- 避免过长的函数（建议 < 100 行）
- 使用有意义的变量名
- 添加必要的注释

## 八、扩展性设计

### 1. 协议扩展

**当前：**
- JSON 格式控制消息

**未来：**
- 支持 Protobuf（性能优化）
- 支持自定义二进制协议

**设计考虑：**
- 协议层与业务层分离
- 支持协议版本协商
- 向后兼容

### 2. 功能扩展

**已规划：**
- Web 管理 UI
- 多路复用
- UDP 协议支持
- TLS 加密

**设计原则：**
- 新功能不影响现有功能
- 通过配置开关控制功能
- 保持 API 稳定性

## 九、常见陷阱与注意事项

### 1. defer 在循环中的使用

**错误示例：**
```go
for {
    conn := ln.Accept()
    defer conn.Close()  // ❌ 错误：defer 在循环中不会执行
}
```

**正确做法：**
```go
for {
    conn := ln.Accept()
    go handleConnection(conn)  // 在函数中使用 defer
}

func handleConnection(conn net.Conn) {
    defer conn.Close()  // ✅ 正确
    // ...
}
```

### 2. 错误检查

**错误示例：**
```go
conn.Close()  // ❌ 忽略了错误
```

**正确做法：**
```go
_ = conn.Close()  // ✅ 明确忽略（如果错误不重要）
// 或
if err := conn.Close(); err != nil {
    log.Printf("关闭连接失败: %v", err)
}
```

### 3. 并发安全

**错误示例：**
```go
mappingTable[port] = mapping  // ❌ 并发不安全
```

**正确做法：**
```go
mappingTableMu.Lock()
defer mappingTableMu.Unlock()
mappingTable[port] = mapping  // ✅ 加锁保护
```

## 十、最佳实践总结

1. **消息边界**：必须使用长度前缀协议解决 TCP 粘包问题
2. **资源管理**：使用 `defer` 确保资源释放，但不要在循环中使用
3. **并发安全**：共享资源必须加锁保护
4. **错误处理**：明确处理所有错误，不要忽略重要错误
5. **心跳保活**：合理设置心跳间隔和超时时间
6. **自动重连**：使用指数退避避免重连风暴
7. **健康探针**：定期检查本地服务状态，避免黑洞代理
8. **代码质量**：保持高测试覆盖率，遵循代码规范
9. **安全考虑**：使用强 token，限制资源使用
10. **可扩展性**：设计时考虑未来扩展，保持接口稳定

---

**文档版本：** v1.0  
**最后更新：** 2024-01-XX  
**维护者：** gotunnel 开发团队

